package leetcode;

/**
 * @Author fxs
 * @Description //TODO
 * @Date 2019/11/19
 **/
public class MinPathSum {
    public static void main(String[] args) {

        /**
         * [
         * [3,8,6,0,5,9,9,6,3,4,0,5,7,3,9,3],
         * [0,9,2,5,5,4,9,1,4,6,9,5,6,7,3,2],
         * [8,2,2,3,3,3,1,6,9,1,1,6,6,2,1,9],
         * [1,3,6,9,9,5,0,3,4,9,1,0,9,6,2,7],
         * [8,6,2,2,1,3,0,0,7,2,7,5,4,8,4,8],
         * [4,1,9,5,8,9,9,2,0,2,5,1,8,7,0,9],
         * [6,2,1,7,8,1,8,5,5,7,0,2,5,7,2,1],
         * [8,1,7,6,2,8,1,2,2,6,4,0,5,4,1,3],
         * [9,2,1,7,6,1,4,3,8,6,5,5,3,9,7,3],
         * [0,6,0,2,4,3,7,6,1,3,8,6,9,0,0,8],
         * [4,3,7,2,4,3,6,4,0,3,9,5,3,6,9,3],
         * [2,1,8,8,4,5,6,5,8,7,3,7,7,5,8,3],
         * [0,7,6,6,1,2,0,3,5,0,8,0,8,7,4,3],
         * [0,4,3,4,9,0,1,9,7,7,8,6,4,6,9,5],
         * [6,5,1,9,9,2,2,7,4,2,7,2,2,3,7,2],
         * [7,1,9,6,1,2,7,0,9,6,6,4,4,5,1,0],
         * [3,4,9,2,8,3,1,2,6,9,7,0,2,4,2,0],
         * [5,1,8,8,4,6,8,5,2,4,1,6,2,2,9,7]
         * ]
         */
        int[][] ints = new int[][]{
                {3,8,6,0,5,9,9,6,3,4,0,5,7,3,9,3},
                {0,9,2,5,5,4,9,1,4,6,9,5,6,7,3,2},
                {8,2,2,3,3,3,1,6,9,1,1,6,6,2,1,9},
                {1,3,6,9,9,5,0,3,4,9,1,0,9,6,2,7},
                {8,6,2,2,1,3,0,0,7,2,7,5,4,8,4,8},
                {4,1,9,5,8,9,9,2,0,2,5,1,8,7,0,9},
                {6,2,1,7,8,1,8,5,5,7,0,2,5,7,2,1},
                {8,1,7,6,2,8,1,2,2,6,4,0,5,4,1,3},
                {9,2,1,7,6,1,4,3,8,6,5,5,3,9,7,3},
                {0,6,0,2,4,3,7,6,1,3,8,6,9,0,0,8},
                {4,3,7,2,4,3,6,4,0,3,9,5,3,6,9,3},
                {2,1,8,8,4,5,6,5,8,7,3,7,7,5,8,3},
                {0,7,6,6,1,2,0,3,5,0,8,0,8,7,4,3},
                {0,4,3,4,9,0,1,9,7,7,8,6,4,6,9,5},
                {6,5,1,9,9,2,2,7,4,2,7,2,2,3,7,2},
                {7,1,9,6,1,2,7,0,9,6,6,4,4,5,1,0},
                {3,4,9,2,8,3,1,2,6,9,7,0,2,4,2,0},
                {5,1,8,8,4,6,8,5,2,4,1,6,2,2,9,7},
        };
        long l2 = System.nanoTime();
        int i = minPathSumNonRecursion(ints);
        long l1 = System.nanoTime();
        double d = (l2-l1);
        System.out.println(d);


        System.out.println(i);
    }


    public static int minPathSumRecursion(int[][] grid) {
        //m 行数 n 列数
        int m = grid.length, n = grid[0].length;

        int[] mArray = new int[n]; //
        int[] nArray = new int[m]; //
        // 初始化
        mArray[0] = grid[0][0];
        nArray[0] = grid[0][0];
        for (int i = 1; i < n; i++) {
            mArray[i] = mArray[i - 1] + grid[0][i];
        }
        for (int i = 1; i < m; i++) {
            nArray[i] = nArray[i - 1] + grid[i][0];
        }

        return uniquePaths(mArray, nArray, m - 1, n - 1, grid);
    }

    public static int minPathSumNonRecursion(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        int[][] dp = new int[row][col];
        dp[0][0] = grid[0][0];
        for(int i = 1; i < row; i++){
            dp[i][0] = dp[i-1][0]+grid[i][0];
        }
        for(int i = 1; i < col; i++){
            dp[0][i] = dp[0][i-1]+grid[0][i];
        }
        for(int i = 1; i <row; i++){
            for(int j =1; j< col; j++){
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }

        return dp[row-1][col-1];
    }

    public static int uniquePaths(int[] m, int[] n, int i, int j, int[][] grid) {

        if (i == 0) {
            return m[j];
        }
        if (j == 0) {
            return n[i];
        }

        int i1 = uniquePaths(m, n, i - 1, j, grid);
        int i2 = uniquePaths(m, n, i, j - 1, grid);

        return Math.min(i1, i2) + grid[i][j];
    }
}
//                  写字楼里写字间，写字间里程序员；  
//                  程序人员写程序，又拿程序换酒钱。  
//                  酒醒只在网上坐，酒醉还来网下眠；  
//                  酒醉酒醒日复日，网上网下年复年。  
//                  但愿老死电脑间，不愿鞠躬老板前；  
//                  奔驰宝马贵者趣，公交自行程序员。  
//                  别人笑我忒疯癫，我笑自己命太贱；  
//                  不见满街漂亮妹，哪个归得程序员？ 